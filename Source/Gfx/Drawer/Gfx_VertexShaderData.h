//==============================================================================
// Filename: Gfx_VertexShaderData.h
// Description: 頂点シェーダデータ作成処理
// Copyright (C) 2022 Silicon Studio Co., Ltd. All rights reserved.
//==============================================================================

#pragma once

//===== インクルード部 =====
#include <Gfx/Gfx_Main.h>

//===== グローバル定数宣言 =====
constexpr int MAX_BONE = 250;       //骨の最大本数

//===== 構造体宣言 =====
struct VtxColor
{
    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    /// コンストラクタ
    ///
    /// \return void
    //--------------------------------------------------------------------------
    VtxColor() noexcept : r(0), g(0), b(0), a(0) {}

    //--------------------------------------------------------------------------
    /// コンストラクタ
    ///
    /// \param[in] rIn  色のrチャンネル
    /// \param[in] gIn  色のgチャンネル
    /// \param[in] bIn  色のbチャンネル
    /// \param[in] aIn  色のaチャンネル
    ///
    /// \return void
    //--------------------------------------------------------------------------
    VtxColor(
        /*[in]*/ unsigned char rIn,
        /*[in]*/ unsigned char gIn,
        /*[in]*/ unsigned char bIn,
        /*[in]*/ unsigned char aIn) noexcept :
        r(rIn), g(gIn), b(bIn), a(aIn)
    {}

    //--------------------------------------------------------------------------
    /// デストラクタ
    ///
    /// \return void
    //--------------------------------------------------------------------------
    ~VtxColor() noexcept {}

    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    unsigned char r;
    unsigned char g;
    unsigned char b;
    unsigned char a;
    //--------------------------------------------------------------------------

    /// <summary>
    /// r   色のrチャンネル
    /// g   色のgチャンネル
    /// b   色のbチャンネル
    /// a   色のaチャンネル
    /// </summary>
};

//===== クラス定義 =====

//***** 頂点情報 *****
class Vertex                //頂点データのベースクラス
{
public:

    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    /// コンストラクタ
    ///
    /// \return void
    //--------------------------------------------------------------------------
    Vertex() noexcept : m_pos() {}

    //--------------------------------------------------------------------------
    /// コンストラクタ
    ///
    /// \param[in] pos  頂点位置
    ///
    /// \return void
    //--------------------------------------------------------------------------
    Vertex(
        /*[in]*/ DirectX::XMFLOAT3 pos) noexcept :
        m_pos(pos)
    {}

    //--------------------------------------------------------------------------
    /// デストラクタ
    ///
    /// \return void
    //--------------------------------------------------------------------------
    ~Vertex() noexcept {}

    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    DirectX::XMFLOAT3 m_pos;
    //--------------------------------------------------------------------------

    /// <summary>
    /// m_pos   頂点位置
    /// </summary>
};

class VertexC  //頂点データ(色付き)
{
public:

    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    /// コンストラクタ
    ///
    /// \return void
    //--------------------------------------------------------------------------
    VertexC() noexcept : m_pos(), m_color() {}

    //--------------------------------------------------------------------------
    /// コンストラクタ
    ///
    /// \param[in] pos      頂点位置
    /// \param[in] color    頂点色
    ///
    /// \return void
    //--------------------------------------------------------------------------
    VertexC(
        /*[in]*/ DirectX::XMFLOAT3 pos,
        /*[in]*/ VtxColor color) noexcept :
        m_pos(pos), m_color(color)
    {}

    //--------------------------------------------------------------------------
    /// デストラクタ
    ///
    /// \return void
    //--------------------------------------------------------------------------
    ~VertexC() noexcept {}

    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    DirectX::XMFLOAT3 m_pos;
    VtxColor m_color;
    //--------------------------------------------------------------------------

    /// <summary>
    /// m_pos       頂点位置
    /// m_color     頂点色
    /// </summary>
};

class VertexT   //頂点データ(UV情報付き)
{
public:

    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    /// コンストラクタ
    ///
    /// \return void
    //--------------------------------------------------------------------------
    VertexT() noexcept : m_pos(), m_uv() {}

    //--------------------------------------------------------------------------
    /// コンストラクタ
    ///
    /// \param[in] pos  頂点位置
    /// \param[in] uv   頂点のUV座標
    ///
    /// \return void
    //--------------------------------------------------------------------------
    VertexT(
        /*[in]*/ DirectX::XMFLOAT3 pos,
        /*[in]*/ DirectX::XMFLOAT2 uv) noexcept :
        m_pos(pos), m_uv(uv)
    {}

    //--------------------------------------------------------------------------
    /// デストラクタ
    ///
    /// \return void
    //--------------------------------------------------------------------------
    ~VertexT() noexcept {}

    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    DirectX::XMFLOAT3 m_pos;
    DirectX::XMFLOAT2 m_uv;
    //--------------------------------------------------------------------------

    /// <summary>
    /// m_pos   頂点位置
    /// m_uv    頂点のUV座標
    /// </summary>
};

class VertexM   //頂点データ(モデル用)
{
public:

    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    /// コンストラクタ
    ///
    /// \return void
    //--------------------------------------------------------------------------
    VertexM() noexcept : m_pos(), m_uv(), m_normal() {}

    //--------------------------------------------------------------------------
    /// コンストラクタ
    ///
    /// \param[in] pos      頂点位置
    /// \param[in] uv       頂点のUV座標
    /// \param[in] normal   頂点の法線
    ///
    /// \return void
    //--------------------------------------------------------------------------
    VertexM(
        /*[in]*/ DirectX::XMFLOAT3 pos,
        /*[in]*/ DirectX::XMFLOAT2 uv,
        /*[in]*/ DirectX::XMFLOAT3 normal) noexcept :
        m_pos(pos), m_uv(uv), m_normal(normal)
    {}

    //--------------------------------------------------------------------------
    /// デストラクタ
    ///
    /// \return void
    //--------------------------------------------------------------------------
    ~VertexM() noexcept {}

    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    DirectX::XMFLOAT3 m_pos;
    DirectX::XMFLOAT2 m_uv;
    DirectX::XMFLOAT3 m_normal;
    //--------------------------------------------------------------------------

    /// <summary>
    /// m_pos       頂点位置
    /// m_uv        頂点のUV座標
    /// m_normal    頂点の法線
    /// </summary>
};

//***** 頂点シェーダ用データ *****
template<class T>
class VsData
{
public:

    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    /// コンストラクタ
    ///
    /// \return void
    //--------------------------------------------------------------------------
    VsData() noexcept : m_vertices(0), m_indices(0) {}

    //--------------------------------------------------------------------------
    /// コンストラクタ
    ///
    /// \param[in] vertices     頂点情報
    /// \param[in] indices      インデックス情報
    /// \param[in] bTriangle    三角形ポリゴンで描画するかどうか
    ///
    /// \return void
    //--------------------------------------------------------------------------
    VsData(
        /*[in]*/ std::vector<T> vertices,
        /*[in]*/ std::vector<unsigned short> indices,
        /*[in]*/ bool bTriangle = true) :
        m_vertices(std::move(vertices)), m_indices(std::move(indices))
    {
        if (m_vertices.size() <= 2 && bTriangle)
            throw ERROR_EX2(S_OK, "【警告】頂点数が2以下！");
        if (m_indices.size() % 3 != 0 && bTriangle)
            throw ERROR_EX2(S_OK, "【警告】インデックス数が3で割り切れない！");
    }

    //--------------------------------------------------------------------------
    /// デストラクタ
    ///
    /// \return void
    //--------------------------------------------------------------------------
    ~VsData() noexcept {}

    //--------------------------------------------------------------------------
    /// サイズ初期化
    ///
    /// \param[in] mtxScale     サイズ情報を持つ4x4行列
    ///
    /// \return void
    //--------------------------------------------------------------------------
    void InitSize(
        /*[in]*/ DirectX::XMFLOAT4X4 mtxScale) noexcept
    {
        //行列作成
        const DirectX::XMFLOAT4X4 scale = mtxScale;
        const DirectX::XMMATRIX mtx = DirectX::XMLoadFloat4x4(&scale);

        //初期化処理
        for (auto& v : m_vertices) {
            const DirectX::XMVECTOR pos = DirectX::XMLoadFloat3(&v.m_pos);
            DirectX::XMStoreFloat3(&v.m_pos, DirectX::XMVector3Transform(pos, mtx));
        }
    }

    //--------------------------------------------------------------------------
    /// 法線計算
    ///
    /// \return void
    //--------------------------------------------------------------------------
    void SetVertexNormal() noexcept(!IS_DEBUG)
    {

#ifdef _DEBUG

        //例外処理
        if (m_vertices.size() <= 2 || m_indices.size() % 3 != 0)
            throw ERROR_EX2(S_OK, "【警告】頂点情報がポリゴンの要件を満たさない！");
        if (m_indices.size() <= 0)
            throw ERROR_EX2(S_OK, "【警告】インデックス情報は空です！");

#endif // _DEBUG

        //計算処理
        for (size_t i = 0, cnt = m_indices.size(); i < cnt; i += 3)
        {
            //ポリゴンの3頂点取得
            auto& vtx0 = m_vertices[m_indices[i]];
            auto& vtx1 = m_vertices[m_indices[i + 1]];
            auto& vtx2 = m_vertices[m_indices[i + 2]];

            //外積で法線算出
            DirectX::XMFLOAT3 v1 = {
                vtx1.m_pos.x - vtx0.m_pos.x,
                vtx1.m_pos.y - vtx0.m_pos.y,
                vtx1.m_pos.z - vtx0.m_pos.z };
            DirectX::XMFLOAT3 v2 = {
                vtx2.m_pos.x - vtx0.m_pos.x,
                vtx2.m_pos.y - vtx0.m_pos.y,
                vtx2.m_pos.z - vtx0.m_pos.z };
            const auto n = DirectX::XMVector3Normalize(DirectX::XMVector3Cross(
                DirectX::XMLoadFloat3(&v1), DirectX::XMLoadFloat3(&v2)));

            //データ格納
            DirectX::XMStoreFloat3(&vtx0.m_normal, n);
            DirectX::XMStoreFloat3(&vtx1.m_normal, n);
            DirectX::XMStoreFloat3(&vtx2.m_normal, n);
        }
    }

    //--------------------------------------------------------------------------
    /// 頂点データ再計算（モデル用）
    ///
    /// \return void
    //--------------------------------------------------------------------------
    void ResetDataForModel() noexcept(!IS_DEBUG)
    {

#ifdef _DEBUG

        //例外処理
        if (m_vertices.size() <= 2 || m_indices.size() % 3 != 0)
            throw ERROR_EX2(S_OK, "【警告】頂点情報がポリゴンの要件を満たさない！");
        if (m_indices.size() <= 0)
            throw ERROR_EX2(S_OK, "【警告】インデックス情報は空です！");

#endif // _DEBUG

        //再計算処理
        std::vector<T> Vertices(0);
        for (auto& i : m_indices) {
            T vtx{};
            vtx.m_pos = m_vertices[i].m_pos;
            Vertices.emplace_back(std::move(vtx));
        }
        m_vertices = std::move(Vertices);
        for (size_t i = 0, Cnt = m_indices.size(); i < Cnt; i++)
            m_indices[i] = static_cast<unsigned short>(i);

        //UV作成（デバッグ用、テクスチャなし）
        for (size_t i = 0, Cnt = m_indices.size() / 3; i < Cnt; i++) {
            m_vertices[i * 3 + 0].m_uv = { 0.0f, 0.0f };
            m_vertices[i * 3 + 1].m_uv = { 1.0f, 0.0f };
            m_vertices[i * 3 + 2].m_uv = { 0.0f, 1.0f };
        }
    }

    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    std::vector<T> m_vertices;
    std::vector<unsigned short> m_indices;
    //--------------------------------------------------------------------------

    /// <summary>
    /// m_vertices  頂点情報
    /// m_indices   インデックス情報
    /// </summary>
};
